from queue import PriorityQueue

def best_first_search(graph, start, goal):
    visited = set()
    queue = PriorityQueue()
    queue.put((0, start))
    while not queue.empty():
        cost, node = queue.get()
        if node == goal:
            return True
        visited.add(node)
        for neighbor in graph[node]:
            if neighbor not in visited:
                queue.put((heuristic(neighbor, goal), neighbor))
    return False

def heuristic(node, goal):
    # Calculate the Manhattan distance between the current node and the goal node
    return abs(node[0] - goal[0]) + abs(node[1] - goal[1])

# Example usage
graph = {
    (0, 0): [(0, 1), (1, 0)],
    (0, 1): [(0, 0), (1, 1)],
    (1, 0): [(0, 0), (2, 0)],
    (1, 1): [(0, 1), (1, 2), (2, 1)],
    (1, 2): [(1, 1)],
    (2, 0): [(1, 0), (2, 1)],
    (2, 1): [(1, 1), (2, 0), (2, 2)],
    (2, 2): [(1, 2), (2, 1)]
}

start = (0, 0)
goal = (2, 2)

if best_first_search(graph, start, goal):
    print("Path found")
else:
    print("Path not found")
